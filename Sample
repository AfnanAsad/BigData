package hydrograph.engine.transformation.userfunctions.aggregate;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;

public class Sample {

    public static void main(String args[])
    {
        Object[] obj={1000,20,30};
        /*Integer[] obj2={10,20,30};
         if(obj[0] instanceof Integer)
                       System.out.println(Arrays.stream(obj).mapToInt(o -> (Integer) o).max());

        int[] t=Arrays.stream(obj).mapToInt(o -> (Integer) o).toArray();
        int sum1=Arrays.stream(obj).mapToInt(o -> (Integer) o).reduce(0, (x, y) -> x + y);
        int min1=Arrays.stream(obj).mapToInt(o -> (Integer) o).max().getAsInt();
        Integer count1=(int)Arrays.stream(obj).mapToInt(o -> (Integer) o).count();
        System.out.println("min"+min1+" "+count1);
        IntStream.of(t).sum();
        int[] numbers = {1, 24, 45, 62, 85, 8, 91, 3, 5, 56, 9};
        Integer total = IntStream.of(numbers).sum();
        Integer count = (int)IntStream.of(numbers).count();
        Integer max = Arrays.stream(numbers).max().getAsInt();
        Integer min = Arrays.stream(numbers).min().getAsInt();

        List<String> list = Arrays.asList("java", "python", "nodejs", "ruby");
        String[] str={"java", "python", "nodejs", "ruby"};
        //java, python, nodejs, ruby
        String result = String.join(",", str);
        System.out.println(result);

        int[][] data = {
                { 1, 2, 0 },
                { 4, 5, 6 }
        };

        int sums = Arrays.stream(data)
                .mapToInt(arr -> arr[0])
                .sum();
       int sums1= Arrays.stream(data).mapToInt(a -> a[0]).sum();
        System.out.println(sums1);*/

        String[] str=Arrays.stream(obj).map(Object::toString).
                toArray(String[]::new);
        String result = String.join(",", str);
        System.out.println(result);
    }
    
    
    
    
    
    
    
     Integer sum = Arrays.stream(obj).flatMapToInt(arr -> Arrays.stream(arr)).sum();
        Long count = Arrays.stream(obj).flatMapToInt(arr -> Arrays.stream(arr)).count();
        Integer max = Arrays.stream(obj).flatMapToInt(arr -> Arrays.stream(arr)).max().getAsInt();
        Integer min = Arrays.stream(obj).flatMapToInt(arr -> Arrays.stream(arr)).min().getAsInt();
        System.out.println("sum "+sum);
        System.out.println("count "+count);
        System.out.println("max   "+max);
        System.out.println("min   "+min);



        Integer[][] data = new Integer[][]{{1000,20,30},{1000,20,30},{1000,20,30},{1000,20,30}};
        Stream<Integer[]> temp = Arrays.stream(data);
        Stream<Integer> stringStream = temp.flatMap(x -> Arrays.stream(x));
        System.out.println("flat count"+stringStream.count());
        stringStream.flatMapToInt(o -> (Integer) o).count();

}






 val schema=StructType(List(StructField("f1", StringType, nullable = true), StructField("f2", StringType, nullable = true), StructField("f3", StringType, nullable = true), StructField("f4", StringType, nullable = true), StructField("f5", StringType, nullable = true)))

    var listf:ListBuffer[StructField]=ListBuffer[StructField]()

    schema.toList.foreach(f=>{
     if(f.name!="f1")
        listf+=StructField(f.name,f.dataType,f.nullable)})

   val newS:StructType=StructType(listf)
